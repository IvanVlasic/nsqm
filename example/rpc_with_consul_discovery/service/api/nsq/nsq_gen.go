// Code generated by go generate; DO NOT EDIT.
package nsq

import (
	"context"
	"io"

	"github.com/minus5/nsqm"
	"github.com/minus5/nsqm/example/rpc_with_consul_discovery/service/api"
	"github.com/minus5/nsqm/rpc"
	nsq "github.com/nsqio/go-nsq"
)

var (
	reqTopic = "service.req"
	rspTopic = "service.rsp"
	channel  = "app"
)

type client struct {
	producer  *nsq.Producer
	consumer  *nsq.Consumer
	transport *rpc.Client
}

func (c *client) Call(ctx context.Context, typ string, req []byte) ([]byte, string, error) {
	return c.transport.Call(ctx, typ, req)
}

func (c *client) Close() error {
	c.producer.Stop()
	c.consumer.Stop()
	return nil
}

func Client() (*api.Client, error) {
	cfgr := nsqm.Local()

	producer, err := nsqm.NewProducer(cfgr)
	if err != nil {
		return nil, err
	}

	transport := rpc.NewClient(producer, reqTopic, rspTopic)

	consumer, err := nsqm.NewConsumer(cfgr, rspTopic, channel, transport)
	if err != nil {
		return nil, err
	}

	return api.NewClient(&client{
		producer:  producer,
		consumer:  consumer,
		transport: transport}), nil
}

type appServer interface {
	Serve(ctx context.Context, typ string, req []byte) ([]byte, error)
}

type server struct {
	producer *nsq.Producer
	cancel   func()
	consumer *nsq.Consumer
}

func (s *server) Close() error {
	s.consumer.Stop() // stop receiving new request
	s.cancel()        // cancel all processing
	s.producer.Stop() // stop producing responses
	return nil
}

func Server(srv appServer) (io.Closer, error) {
	cfgr := nsqm.Local()

	producer, err := nsqm.NewProducer(cfgr)
	if err != nil {
		return nil, err
	}

	ctx, cancel := context.WithCancel(context.Background())
	transport := rpc.NewServer(ctx, srv, producer)

	consumer, err := nsqm.NewConsumer(cfgr, reqTopic, channel, transport)
	if err != nil {
		return nil, err
	}

	return &server{
		producer: producer,
		cancel:   cancel,
		consumer: consumer,
	}, nil
}
